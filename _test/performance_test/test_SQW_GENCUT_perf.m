classdef test_SQW_GENCUT_perf < TestPerformance
    % Test checks performance achieved during sqw file generation and
    % different cuts, done over the test sqw files.
    %
    % The performance results (in second) are stored in a matlab binary file
    % combining results for all hosts where the tests were run
    % The format of the file is as follows:
    % -host_name1->test_name1(nworkers)->test_time(sec)
    %           |->test_name2(nworkers)->test_time(sec)
    %           |->test_name3(nworkers)->test_time(sec)
    % -host_name2->test_name1(nworkers)->test_time(sec)
    %           |->test_name2(nworkers)->test_time(sec)
    %           |->test_name3(nworkers)->test_time(sec)
    %
    % where nworkers is the number of parallel workers used to process the
    % data  and the test_name is the name, specified as input to
    % save_or_test_performance method
    % The host_name is the variable combined from the preffix containign the
    % output of Hergbert getHostName function
    % and the suffix containing the number of files used as the input for
    % the test.
    %
    % HACK: currently the test uses large real nxspe file specified as value
    % of the property template_file_. The file size is large then the whole
    % Horace codebase, so there are no point of keeping it in SVN. Currently
    % this file should be distributed manually or randomly choosen from the
    % files avaiible to user In a future, such file should be autogenerated.
    %
    %
    % $Revision$ ($Date$)
    %
    properties(Dependent)
        %  Number of input files to use. Depending on this number the test
        %  would verify small, large or huge datasets
        n_files_to_use% = 10;
    end
    
    properties
        % directory, containing data file necessary for the tests
        source_data_dir
        % directory to keep temporary working files
        working_dir
        %
        % target file for gen_sqw command and source file for cut commands
        sqw_file = 'GenSQW_perfTest.sqw'
    end
    
    properties(Access=private)
        % list of source files to process
        test_source_files_list_
        %
        %  Number of input files to use. Depending on this number the test
        %  would verify small, large or huge datasets
        n_files_to_use_ = 10;
        % Template file name: the name of the file used as a template for
        % others. HACK. Nice version would generate test source files from
        % some scattering and instrument models.
        template_file_ = 'MER19566_22.0meV_one2one125.nxspe';
        % parameter file
        par_file = 'one2one_125.par'
        
    end
    methods
        %------------------------------------------------------------------
        function nf = get.n_files_to_use(obj)
            % number of test files, used in performance tests
            nf = obj.n_files_to_use_;
        end
        %------------------------------------------------------------------
        function obj = test_SQW_GENCUT_perf(varargin)
            % create test suite, generate source files and load existing
            % perfomance data.
            %
            if nargin > 0
                argi = varargin;
            else
                argi = {'SQW_GENCUT_perf',...
                    TestPerformance.default_PerfTest_fname(mfilename('fullpath'))};
            end
            obj = obj@TestPerformance(argi{:});
            %
            obj.source_data_dir = pwd();
            % locate the test data folder
            stat = mkdir('test_SQWGEN_performance_rw_test');
            clob = onCleanup(@()rmdir('test_SQWGEN_performance_rw_test','s'));
            if stat == 1
                clear clob;
                obj.working_dir = obj.source_data_dir;
            else
                obj.working_dir = tmpdir;
            end
            % set up the default number of files to use and prepare all
            % dependent properties to work with them.
            obj.n_files_to_use = obj.n_files_to_use_;
            % add target sqw files to cleanList to delete it after test is
            % completed.
            obj.add_to_files_cleanList(obj.sqw_file);
        end
        %-------------------------------------------------------------
        
        function set.n_files_to_use(obj,val)
            % change number of files to use and modify all related
            % internal properties which depends on this number
            %
            obj.n_files_to_use_ = floor(abs(val));
            if obj.n_files_to_use_ < 1
                obj.n_files_to_use_ = 1;
            end
            % change performance suite name as different number of input
            % files has different impact on performance
            perf_test = obj.build_test_suite_name(['nf',num2str(obj.n_files_to_use_)]);
            obj.perf_suite_name = perf_test;
            
            %
            filelist = source_nxspe_files_generator(obj.n_files_to_use,...
                obj.source_data_dir,obj.working_dir,obj.template_file_);
            % delete generated files after the test completed.
            obj.add_to_files_cleanList(filelist);
            obj.test_source_files_list_ = filelist;
            fb = 'GenSQW_perfTest';
            obj.sqw_file = sprintf('%s_%dFiles.sqw',fb,obj.n_files_to_use_);
        end
        %--------------------------------------------------------------------------
        function perf_val=combine_performance_test(obj,varargin)
            % this method tests tmp file combine operations only. It can be
            % deployed after test_gensqw_performance method has been run
            % with hor_config class delete_tmp option set to false. In this
            % case tmp files created by gen_sqw method are kept and this
            % method may test combime operations only.
            %
            % Usage:
            % tob.combine_performance_test([n_workers])
            % where n_workers, if present, specify the number of parallel
            % workers to run the test routines with.
            %
            % As this test method violates unit test agreement, demanding
            % test method independence on each other, it does not start
            % from the name test to avoid running it by automated test
            % suites.
            if nargin == 1
                n_workers = 0;
            else
                n_workers = varargin{1};
            end
            [clob_wk,hpc] = check_and_set_workers_(obj,n_workers);
            
            
            
            function fn = replace_fext(fp,fn)
                [~,fn] = fileparts(fn);
                fn = fullfile(fp,[fn,'.tmp']);
            end
            hc = hor_config;
            wk_dir = hc.working_directory;
            spe_files = obj.test_source_files_list_;
            tmp_files = cellfun(@(fn)(replace_fext(wk_dir,fn)),spe_files,'UniformOutput',false);
            
            % check all tmp files were generated
            f_exist = cellfun(@(fn)(exist(fn,'file')==2),tmp_files,'UniformOutput',true);
            
            assertTrue(all(f_exist),'Some tmp files necessary to run the test do not exist. Can not continue');
            
            umc = hpc.use_mex_for_combine;
            if umc
                mode = hpc.mex_combine_thread_mode;
                combine_method = sprintf('MEX_mode%d',mode);
            else
                combine_method='MATLAB';
            end
            
            
            ts = tic();
            write_nsqw_to_sqw(tmp_files,obj.sqw_file);
            %
            perf_val=obj.assertPerformance(ts,...
                ['combine_tmp_using_',combine_method],...
                'performance of the tmp-files combine procedure');
            
            % spurious check to ensure the cleanup object is not deleted
            % before the end of the test
            assertTrue(isa(clob_wk,'onCleanup'))
            
            obj.delete_files(tmp_files);
            
        end
        %------------------------------------------------------------------
        function perf_res= test_gensqw_performance(obj,varargin)
            % test performance (time spent on processing) class-defined
            % number of files using number of workers provided as input
            %
            % Usage:
            % tob.combine_performance_test([n_workers])
            % where n_workers, if present, specify the number of parallel
            % workers to run the test routines with.
            %
            % n_workers>1 sets up parallel file combining.
            % if n_workers==0 or absent the class does not change the
            % number of workers defined by current Horace configuration.
            if nargin == 1
                n_workers = 0;
            else
                n_workers = varargin{1};
            end
            clob_wk = check_and_set_workers_(obj,n_workers);
            
            nwk = num2str(n_workers);
            efix= 22.8;%incident energy in meV
            
            emode=1;%direct geometry
            alatt=10.7488*[1 1 1];%lattice parameters [a,b,c]
            angdeg=[90,90,90];%lattice angles [alpha,beta,gamma]
            u=[1,1,0];%u=// to incident beam
            v=[0,0,1];%v= perpendicular to the incident beam, pointing towards the large angle detectors on Merlin in the horizontal plane
            omega=0;
            dpsi=-1.8464+(0.9246);
            gl=-3.1871+(-0.1634);
            gs=-1.7047+(0.0028);
            
            nfiles=numel(obj.test_source_files_list_);
            psi= 0.5*(1:nfiles);
            %psi=round(psi);
            ts = tic();
            
            gen_sqw (obj.test_source_files_list_,'',obj.sqw_file, efix, emode, alatt, angdeg,u, v, psi, omega, dpsi, gl, gs,'replicate');
            
            obj.assertPerformance(ts,['gen_sqw_nwk',nwk],...
                'whole sqw file generation');
            
            % test small 1 dimensional cuts, non-axis aligned
            ts = tic();
            proj1 = struct('u',[1,0,0],'v',[0,1,1]);
            sqw1 = cut_sqw(obj.sqw_file,proj1,0.01,[-0.1,0.1],[-0.1,0.1],[-5,5]);
            obj.assertPerformance(ts,['cutH1D_Small_nwk',nwk],...
                'small memory based 1D cut in non-axis aligned direction 1');
            
            ts = tic();
            sqw1 = cut_sqw(obj.sqw_file,proj1,[-0.1,0.1],0.01,[-0.1,0.1],[-5,5]);
            obj.assertPerformance(ts,['cutK1D_Small_nwk',nwk],...
                'small memory based 1D cut in non-axis aligned direction 2');
            
            ts = tic();
            sqw1 = cut_sqw(obj.sqw_file,proj1,[-0.1,0.1],[-0.1,0.1],0.01,[-5,5]);
            obj.assertPerformance(ts,['cutL1D_Small_nwk',nwk],...
                'small memory based 1D cut in non-axis aligned direction 3');
            
            ts = tic();
            sqw1 = cut_sqw(obj.sqw_file,proj1,[-0.1,0.1],[-0.1,0.1],[-0.1,0.1],0.2);
            obj.assertPerformance(ts,['cutE_Small_nwk',nwk],...
                'small memory based 1D cut along energy direction (q are not axis aligned)');
            
            % check nopix performance -- read and integrate the whole file from the HDD
            hs = head_sqw(obj.sqw_file);
            urng = hs.urange';
            ts = tic();
            proj1 = struct('u',[1,0,0],'v',[0,1,1]);
            sqw1=cut_sqw(obj.sqw_file,proj1,0.01,urng(2,:),urng(3,:),urng(4,:),'-nopix');
            obj.assertPerformance(ts,['cutH1D_AllInt_nopix_nwk',nwk],...
                'large 1D cut direction 1 with whole dataset integration along 3 other directions. -nopix mode');
            
            ts = tic();
            sqw1=cut_sqw(obj.sqw_file,proj1,urng(1,:),0.01,urng(3,:),urng(4,:),'-nopix');
            obj.assertPerformance(ts,['cutK1D_AllInt_nopix_nwk',nwk],...
                'large 1D cut direction 2 with whole dataset integration along 3 other directions. -nopix mode');
            
            ts = tic();
            sqw1=cut_sqw(obj.sqw_file,proj1,urng(1,:),urng(2,:),0.01,urng(4,:),'-nopix');
            obj.assertPerformance(ts,['cutL1D_AllInt_nopix_nwk',nwk],...
                'large 1D cut direction 3 with whole dataset integration along 3 other directions. -nopix mode');
            
            ts = tic();
            sqw1=cut_sqw(obj.sqw_file,proj1,urng(1,:),urng(2,:),urng(3,:),0.2,'-nopix');
            
            obj.assertPerformance(ts,['cutE_AllInt_nopix_nwk',nwk],...
                'large 1D cut along energy direction with whole dataset integration along 3 other directions. -nopix mode');
            
            
            % test large 1 dimensional cuts, non-axis aligned, with whole
            % integration. for big input sqw files this should go to
            % file-based cuts
            fl2del = {'cutH1D_AllInt.sqw','cutK1D_AllInt.sqw',...
                'cutL1D_AllInt.sqw','cutE_AllInt.sqw'};
            clob1 = onCleanup(@()obj.delete_files(fl2del));
            
            ts = tic();
            proj1 = struct('u',[1,0,0],'v',[0,1,1]);
            cut_sqw(obj.sqw_file,proj1,0.01,urng(2,:),urng(3,:),urng(4,:),'cutH1D_AllInt.sqw');
            obj.assertPerformance(ts,['cutH1D_AllInt_filebased_nwk',nwk],...
                'large file-based 1D cut. Direction 1; Whole dataset integration along 3 other directions');
            
            ts = tic();
            cut_sqw(obj.sqw_file,proj1,urng(1,:),0.01,urng(3,:),urng(4,:),'cutK1D_AllInt.sqw');
            obj.assertPerformance(ts,['cutK1D_AllInt_filebased_nwk',nwk],...
                'large file-based 1D cut. Direction 2; Whole dataset integration along 3 other directions');
            
            ts = tic();
            cut_sqw(obj.sqw_file,proj1,urng(1,:),urng(2,:),0.01,urng(4,:),'cutL1D_AllInt.sqw');
            obj.assertPerformance(ts,['cutL1D_AllInt_filebased_nwk',nwk],...
                'large file-based 1D cut. Direction 1; Whole dataset integration along 3 other directions');
            
            ts = tic();
            cut_sqw(obj.sqw_file,proj1,urng(1,:),urng(2,:),urng(3,:),0.2,'cutE_AllInt.sqw');
            perf_res=obj.assertPerformance(ts,['cutE_AllInt_filebased_nwk',nwk],...
                'large file-based 1D cut. Energy direction; Whole dataset integration along 3 other directions');
            
            % spurious check to ensure the cleanup object is not deleted
            % before the end of the test
            assertTrue(isa(clob_wk,'onCleanup'))
        end
    end
    methods(Access=private)
        function [clob,hc] = check_and_set_workers_(obj,n_workers)
            % function verifies and sets new number of MPI workers
            %
            % returns cleanup object which returns the number of temporary
            % workers to its initial value on destruction
            %  if input n_workers == 0, current number of parallel
            % workers remains unchanged
            %
            hc = hpc_config;            
            if n_workers == 0 % keep existing number of workers unchanged
                clob = onCleanup(@()(0));
                return;
            end
            as = hc.accum_in_separate_process;
            an = hc.accumulating_process_num;
            if as && an > 1
                clob = onCleanup(@()set(hc,'accum_in_separate_process',as,'accumulating_process_num',an));
            else
                clob = onCleanup(@()(an));
            end
            if (n_workers>0 && ~as)
                hc.accum_in_separate_process = true;
                hc.accumulating_process_num = n_workers;
            end
            
        end
    end
end
